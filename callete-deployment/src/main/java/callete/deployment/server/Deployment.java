package callete.deployment.server;

import callete.api.util.SystemUtils;
import callete.deployment.util.DeploymentArchiver;
import callete.deployment.util.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * The actual deployment actions, like unpacking the deployment archive, building and installing it.
 */
public class Deployment {
  private final static Logger LOG = LoggerFactory.getLogger(Deployment.class);

  public final static String CMD_CREATE = "create";
  public final static String CMD_DESTROY = "destroy";
  public final static String CMD_CLEAN = "clean";
  public final static String CMD_RUN = "run";
  public final static String CMD_COPY = "copy";

  private DeploymentStatus status = new DeploymentStatus();
  private Process deployedProcess;

  public Deployment(String target) {
    status.setDeploymentDirectory(target);
  }

  /**
   * Ensures that the new deployment can be executed
   * in the given target directory.
   *
   * @return The current deployment status
   */
  public DeploymentStatus create() {
    if (status.getDeploymentDirectory() == null) {
      status.setErrorMessage("Deployment directory has not been set, check log for details.");
      return status;
    }

    File target = new File(status.getDeploymentDirectory());
    target.mkdirs();
    if (!target.exists()) {
      status.setErrorMessage("Could not create deployment directory '" + status.getDeploymentDirectory() + ", " +
              "please create it manually.");
    }
    return status;
  }

  public DeploymentStatus getStatus() {
    return status;
  }

  /**
   * Destroys the forked process this deployment is running.
   */
  public DeploymentStatus destroy() {
    if(deployedProcess != null) {
      deployedProcess.destroyForcibly();
    }
    return status;
  }

  /**
   * Cleans up the target folder that is stored in the DeploymentStatus.
   * A clean install is ensured for the next deployment this way.
   * @param ignoreList The list of directories to ignore when cleaning the target directory.
   * @param quickDeployment
   */
  public DeploymentStatus clean(List<String> ignoreList, boolean quickDeployment) {
    try {
      File targetDirectory = new File(status.getDeploymentDirectory());
      //delete all if this is no quick deployment
      if(!quickDeployment) {
        FileUtils.deleteFolder(targetDirectory, ignoreList, true);
      }
      else {
        //delete only main jar
        File[] list = targetDirectory.listFiles(new FilenameFilter() {
          @Override
          public boolean accept(File dir, String name) {
            return name.endsWith(".jar");
          }
        });
        for(File file : list) {
          if(file.delete()) {
            LOG.info("Quick-Deployment deleted " + file.getAbsolutePath());
          }
        }
      }

    } catch (IOException e) {
      LOG.error("Error during deployment cleanup: " + e.getMessage());
      status.setErrorMessage(e.getMessage());
    }

    return status;
  }

  /**
   * Unpacks the deployment archive into the target directory.
   *
   * @param deploymentArchive the archive that contains the maven project to build.
   */
  public DeploymentStatus copy(File deploymentArchive) {
    try {
      deploymentArchive.deleteOnExit();
      LOG.info("Created deployment tmp file " + deploymentArchive.getAbsolutePath());
      status.setTmpFile(deploymentArchive.getAbsolutePath());
      FileUtils.unzip(deploymentArchive, new File(status.getDeploymentDirectory()));
    } catch (IOException e) {
      LOG.error("Error unpacking deployment archive: " + e.getMessage());
      status.setErrorMessage(e.getMessage());
    }

    return status;
  }

  /**
   * Runs the maven target that will start the deployed programm
   */
  public DeploymentStatus run() {
    executeDeployment();
    return status;
  }


  /**
   * Executes a system command, using the batch file that
   * has been generated by the deployment archiver class.
   * Returns true if the process execution was successful.
   */
  private boolean executeDeployment() {
    try {
      List<String> cmds = new ArrayList<>();

      //determine batch file
      File batchFile = new File(status.getDeploymentDirectory(), DeploymentArchiver.RUN_SCRIPT_NAME + ".sh");
      if(SystemUtils.isWindows()) {
        batchFile = new File(status.getDeploymentDirectory(), DeploymentArchiver.RUN_SCRIPT_NAME + ".bat");
      }

      //mpf, well, just read the system command from the file, so no chmod required AND we can kill the process!
      List<String> lines = org.apache.commons.io.FileUtils.readLines(batchFile, "UTF-8");
      String cmdString = lines.get(0);
      LOG.info("***************** Executing system command: ***********************************");
      LOG.info(cmdString);
      LOG.info("***************** /Executing system command ***********************************");
      String[] batchCmds = cmdString.split(" ");
      cmds.addAll(Arrays.asList(batchCmds));

      LOG.info("Executing batch script in directory " + status.getDeploymentDirectory());
      final ProcessBuilder processBuilder = new ProcessBuilder(cmds).inheritIO().redirectErrorStream(true);

      //determine the directory the maven call should be executed.
      File deploymentDirectory = new File(status.getDeploymentDirectory());
      processBuilder.directory(deploymentDirectory);

      //execute the process build
      deployedProcess = processBuilder.start();
    } catch (Exception e) {
      LOG.error("Error installing deployment: " + e.getMessage());
      status.setErrorMessage(e.getMessage());
      return false;
    }
    return true;
  }
}
